static靜態函數，不用依靠物件

。Console.WriteLine("a的值是"+a+"b的值是"+b);    <=value type

。Console.WriteLine("a的值是{0}，b的值是{1}，現在時間是{2}",a,b,DateTime.Now);        <=格式化對應

。Console.WriteLine($"a的值是{a}，b的值是{b}，現在時間是{DateTime.Now.ToString("hh-mm-ss")}");    <=格式化

arry 參考型別

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307215627949445130/image.png?ex=673d736c&is=673c21ec&hm=ff4bc804ab08d2cd29455f6c78329bff1c01bd7f023ae630de342a224c603355&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307216243547312258/image.png?ex=67397f7f&is=67382dff&hm=f9221f85f53343fbd842807c124733f8dd41c769016aba33544c5e4c2db74cbb&=)

陣列為參考型別。

。一般string int char ....為value type ，call-by-value

，call-by-reference

value type =>    int     a , string b arry2;

reference type   

arry2被Add呼叫過去後會去產生int [ ]a1，在Add裡面a1[2]被改變成15，則回傳回去後arry2[2]也會變成15;直接改變

。class級別 ststic不用new物件

call-by-name c#沒有。

value type：call-by-value

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307226075604189205/image.png?ex=673988a7&is=67383727&hm=9f211cee26d82ac9229ffa55043715df818b9913f2c4a2ebdae6844fbfb3ccbc&=)

call-by-reference

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307226328008888411/image.png?ex=673d7d63&is=673c2be3&hm=1589df4d0ca6d5195aacbc913b745ded683fd0ba6bfce89eb9ec417ac54e487e&=)

初始值呼叫後如果在方法中有更動則原值也會更動

。初始值為無值、方法計算後給值，讓初始值給值。call-by-out

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307229522969759745/image.png?ex=67398bdd&is=67383a5d&hm=05541476c694cf06334c493e50bedec6d1cac94fa9323317a1071ad3164256ff&=)

Swap交換

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307231905195753513/image.png?ex=673ed415&is=673d8295&hm=a64c3feddd6cd89af654917894b0c390d90e2abb31d8e2785eae7d3525a348ff&=)

實際上沒有真正的交換，value type不會動到初始值;

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307232106270687322/image.png?ex=673ed445&is=673d82c5&hm=1fef52a0eaae3afa157ff3c8629e2750b2b8891cfd5aa4d1f082ce3beea4248b&=)

加上ref後：

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307232656957636638/image.png?ex=673ed4c8&is=673d8348&hm=d301c06c0aa429420014dcd638f53e6b3a4d00dae692cf9a5f571112ed3998ba&=)

執行結果：

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307232846305427496/image.png?ex=673ed4f5&is=673d8375&hm=aa80608f5cf5c41c299685aabf5230e4cd99124b4cb702df1a7a154b3915ebb9&=)

有成功改變。

。Concat串接

string s5=string.Concat(s1, s2);

。Join合併，並在連接處可以加上符號。

string s6=string.Join("-", s1,s2,s3);

。Console.WriteLine(s6.ToUpper());變大寫

。Console.WriteLine(s6.StartsWith("HE")); 比對開頭的字串

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307251227461029888/image.png?ex=673ee614&is=673d9494&hm=9f6a5198fb96572195c2652730854d18dd2a237e14a9637ad9ad8f784aa502e0&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307261298236456970/image.png?ex=673eef75&is=673d9df5&hm=f83093c3ce9cf095e2705872ce2e1488eeff97682312f04990935a37ba141269&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307261997087195238/image.png?ex=6739aa1b&is=6738589b&hm=e82383eeb1a0d2415132e2dfbd8d69e94999f80bef9d0663cb5ea242111f9755&=)

c4 是指向c3的空間所以當c3有變動的話，c4也會改變。

## 。存取

<img src="https://cdn.discordapp.com/attachments/1303971581025980426/1307276729122820096/image.png?ex=6739b7d4&is=67386654&hm=5d69c887ff2ac1579b2adca29611e06dabb31dfec36829bdac1e2f9ff6c24092&=" title="" alt="" width="512">

<mark>**資料結構重點：**</mark>

1.程式執行速度快

2.資料占用最少的記憶空間

3.更快速的存取這些資料

。基本資料型態：

整數int

浮點數float

字元char

。虛擬資料型態

字串string

陣列arry

指標pointer

串列list

檔案file

##### 演算法五大條件：

。輸入

。輸出

。明確性

。有限性 ，**最重要**

。有效性

```
namespace power
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int x, y;
            Console.WriteLine("請輸入基數：");
            x =Convert.ToInt32(Console.ReadLine());
            Console.WriteLine("請輸入次方數：");
            y = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine($"{x}的{y}次方值為{power(x,y)}");
        }
        static int power(int a, int b)
        {
            if (b == 0)
                return 1;
            else
            {
                return a * power(a, b - 1);
            }
        }
    }
}
```

滿足演算法的條件：

正確得執行結果

可維護性高

執行效率高

。硬體資源的使用

。執行時間成本

。空間複雜度分析

    -固定記憶體空間

    。程式本身、靜態變數和常數等所佔用記憶體空間

    。程式輸出入的資料量並沒有關係

    。程式編譯完成時，即可確定使用的記憶體空間

    -動態(變動)記憶體空間。run-time

    。在程式執行過程所需的額外記憶體空間，動態new東西出來；ex:函數參數、遞迴參數

        的堆疊空間、程式動態配置的記憶體空間。

    。與輸出入的資料量、函數參數個數、遞迴呼叫次數而動態改變有關。

。ex計算程式執行的時間：

a=a+1;

上述程式碼將變數a的值+1，如果使用for迴圈執行此程式碼n次，如下所示：

for (i =0 ;i<n ;i++)

{ a=a+1 }

上述迴圈內程式碼執行的全部時間為n*t

t為單獨執行a=a+1 程式碼的時間

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307306100932083712/image.png?ex=6739d32f&is=673881af&hm=638b34943ae23e578a61e5a095a39c27562d5e5ad04a036c517660a827b0e141&=)

```
    namespace shortcut
{
    internal class Program
    {
        static void Main(string[] args)
        {
           int a=0,b=10;
            if (((b++) >= 10) && (a < 0) )
            {
                Console.WriteLine("成立");
            }
            else 
            {
                Console.WriteLine("不成立");
            }
            Console.WriteLine($"b的值為{b}");
        }
    }
}
```

##### 。    <mark>頻率次數：</mark>

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307309139894075404/image.png?ex=6739d603&is=67388483&hm=6214a61ed0b82392fea37348a861d6e45f48e4ea932c94aa6a2db3798fd8fc43&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307309827235512331/image.png?ex=6739d6a7&is=67388527&hm=7c46aabd8a78a706bad8bdcc68ebf61ee80af6af15d0036fc2d4f89f7aeca454&=)

。指定敘述和運算式=> EX：a=30 ; a=b++;

。執行函數=> EX：Console.WriteLine();

===============================================================

計算頻率計數：

函數sumArray()可以計算參數陣列元素的總和：

```
static int sumArry(int[]data,int n){
int i,total =0;
for (i=0;i<n;i++)
    total+=data[i];    
return total;
}
```

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307311519293378560/image.png?ex=6739d83a&is=673886ba&hm=4fb9e0e3294e242403ef410a030848a1110332a444323893327179f69ea0e8d1&=)

01行 宣告 所以不計數。

02行 宣告 但後面有個=就是指定運算 所以計數。

03行 for迴圈 從0跑到n-1 所以距離為n-0 for迴圈會比本身底下內容多跑一次因為還有i++ 接著在i<n判斷後離開

04行執行n次

05行 1次

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307314327178580018/image.png?ex=6739dad8&is=67388958&hm=506f5aeb7476999fb00caa9e11dfd8af1369e8f1db2bebdb1e97b96d3238b273&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307318379727818772/image.png?ex=6739de9e&is=67388d1e&hm=a741067f2a00279c591cd677864df280d071c379dcc3d6d125e99c719a2d646e&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307319260179333181/image.png?ex=6739df70&is=67388df0&hm=acf208cee1d4ee80b7593da2a39100978a96d612b0ffff9721ca07269c9c280c&=)

共2n次 

ex：n=5

則02行會跑5次，03行1次，04行無，05行4次

共計10次。

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307319077517398046/image.png?ex=6739df44&is=67388dc4&hm=4d11a9f56c6a69f4508cb32a77304437c6e167127b4e826ce87d4dd690ab8c96&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1307319877463179314/image.png?ex=6739e003&is=67388e83&hm=620285000bf7b9c0f02afd1f1cd756942e30d78eddfdcf131333b947d9d8ffea&=)

**概量：衡量執行時間就稱為時間複雜度。**

T(n)來表示程式執行所需要的花費時間，n代表資料輸入量，程式執行時間或最大執行時間做為衡量一般以Big-oh表示O

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308054123077304413/image.png?ex=673c8bd5&is=673b3a55&hm=37027d7c71d8f892c8770c52d3e222fa42c4371b6d976ed91d9fe078472ce015&=)

Big-O取最高次方項，Big-O用來表示最壞執行時間

-----------------------------------------------------------------------------------------------------------------------

- **3n+2 = O(n)**
  - 我們選擇 c = 4，n0 = 2，那麼當 n ≥ 2 時，3n+2 ≤ 4n 總是成立。
- **10n^2+5n+1 = O(n^2)**
  - 我們選擇 c = 11，n0 = 6，那麼當 n ≥ 6 時，10n^2+5n+1 ≤ 11n^2 總是成立

---------------------------------------------------------------------

再以 3n+2 = O(n) 為例，更詳細地說明：

1. **選擇 c = 4，n0 = 2：** 我們之所以選擇 c = 4 和 n0 = 2，是因為當 n ≥ 2 時，不等式 3n+2 ≤ 4n 總是成立。

2. **驗證不等式：**
- 當 n = 2 時，O會換成c給的數值，則會變成3n+2 = 4(n)，接著變成3(2)+2=4(2)，兩者相等。

- 當 n > 2 時，隨著 n 的增加，4n 的增長速度明顯快於 3n+2。這是因為 4n 的係數 4 大於 3n+2 中 n 的係數 3。

- 因此，對於所有 n ≥ 2 的情況，不等式 3n+2 ≤ 4n 都成立。

----------------------------------------------------------------------------------

<mark>。c的值選擇</mark>

**選擇一個大於最高階項係數的數作為 c：** 為了確保比較函數的成長速度總是快於或等於原函數，我們可以選擇一個大於最高階項係數的數作為 c。在 3n+2 的例子中，3 是最高階項的係數，所以我們可以選擇 c = 4、5、6 或更大的數。

-----------------------------------------------------------------------------------

<mark>。n0的值選擇</mark>

**例子 1：3n+2 = O(n)**

- 不等式：3n+2 ≤ 4n
- 化簡：n ≥ 2
- n0 = 2

**例子 2：10n^2+5n+1 = O(n^2)**

- 不等式：10n^2+5n+1 ≤ 11n^2
- 化簡：n ≥ 6
- n0 = 6

================================================

##### <mark>Ω(omega)​</mark>

。Ω就是執行時間量度的最好狀況。

對所有的n值而言，n>= n0時，f(n)>=cg(n)均成立

f(n)=5n+6，存在c=5 n0=1，對所有n>=1時，5n+6>=5n，因此f(n)= Ω(n)而言，n就是成長的最大函數。​

------------------------------------------------

3n+2=Ω(n)​

∵當c=3，n0=0，3n+2≧3n​

∴ 3n+2 的Ω為 n

在此c可以取0~3

下列假設c=3

3n+2=c(n)​

。n=0

0、2>=0

。n=1

5>=3

。n=2

8>=6

=============================================================

##### θ(theta)

(n)= θ(g(n))(讀作”big-theta of g(n)”)，意是存在常數c1、c2、n0，對所有的n>=n0時，c1g(n)<=f(n)<=c2g(n)均成立。換句話說，當f(n)= θ(g(n))時，就表示g(n)可代表f(n)的上限與下限。​

----------------------------------------------------

3n+1= θ(n)​

∵當 c1=3，c2=4，且n0=1，3n≦ 3n+1 ≦4n​

∴ 3n+1 的 θ為 n​

----------------------------------------------------------------------------------

- 以f(n)=n^2+2n為例​
  
  - 當n>=0時，n^2+2n<=3n^2，可得f(n)=O(n^2)。​
  
  - 同理，n>=0時，n^2+2n>=n^2，可得f(n)=Ω(n^2)。​
  
  - 所以f(n)=n^2+2n=θ(n^2)

==============================================

#### 實數表示法​

- 實數的組成包含三個部分：符號位元(Sign Bit)、指數部分(Exponent)與假數部分(Mantissa)​

- 符號位元則是用來表示正負號

- 而指數部分與假數部分是用來紀錄實數在轉換成二進制科學表示法後的資訊​
  
  - 舉例：(轉成科學記號)
  
  - 131.415 = 1.31415*10^2
  
  - 0.131415 = 1.31415*10^-1

- 指數：規模大小

- 假數：精確度，切越細越精確

--------------------------------------------------------------------------------------

Float浮點數4Bytes=>32bits

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308332985015341056/image.png?ex=673d8f8b&is=673c3e0b&hm=6d3020cf93cb40b61f108a3f299a9bda8e2d33e30d27a1a775866e14ab56d341&=)

。b31(1bit)=>正/負；0是正數、1是負數

。b30~b23(8bit)=>指數，規模大小，8 個位元可以顯示 0 ~255個數值, 但必須能顯示正負兩種指數, 故以 127為指數偏差值

。b22~b0(23bit)=>假數，精確度，以二進位形式, 且正規化後的浮點數之小數部份。​

--------------------------------------

舉例：10進位

float  a=(12.25)10

正規化=>

12.25為正數所以b31為0

12轉成2進位為=>1100

0.25也要轉2進位=>01

12.25 =2進位=> 

(1100.01)2，正規化成1.<u>10001</u>*2^3     //b22~b0(23bit)底線為精確度的部分

偏差指數為3+127=130=>(10000010)2     //b30~b23(8bit)

完整表示為，b22~b0如果上方算完後由左至右依序填入，如果未滿23bit，則剩餘皆填入0

01000001010001000000000000000000

==================================================

#### 陣列結構：

。儲存結構：

1、靜態資料結構=>arry

2、動態資料結構=>linked-list

##### <mark>。 宣告陣列時須定義下列幾項屬性：​</mark>

- 陣列的**資料型態**​

- **起始位址**，表示陣列名稱(或陣列第一個元素)所在記憶體中的起始位址。​

- 陣列的**維度**(dimension)，即中括號([ ])的個數，如一維陣列、二維陣列、三維陣列等等。​

- **陣列每一維度的元素個數**，亦即陣列大小。​

- 索引上下限：指元素在此陣列中，記憶體所儲存位置的上標與下標。​

- **陣列元素的初值，此項可以省略**。​
  
  

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308760995241525279/image.png?ex=673f1e28&is=673dcca8&hm=cf04b4127de2a7b18908666d4cda148473a28521fa287c60c2d3a88010379b18&=)

<img title="" src="https://cdn.discordapp.com/attachments/1303971581025980426/1308761239375183892/image.png?ex=673f1e63&is=673dcce3&hm=2809885df651986e0e689f4b1348c186adc5db2c42081d3e6278cbedfde3eb56&=" alt="" data-align="left" width="716">



<style type="text/css"></style>

|     |     |                    |     |     |
| --- | --- | ------------------ | --- | --- |
|     |     | **<mark>。</mark>** |     |     |

陣列大小=>a[2][5]

求螢光區的記憶體位置

可以依照底下code完成

```
namespace prj1120_pratice
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int[] data1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            int[,] data2 = { { 1, 2, 3, 4, 5 }, { 6, 7, 8, 9, 10 } };
            unsafe
            {//fixed固定系統給予的空間
                fixed (int* ptr = data1)//指標
                {
                    for (int i = 0; i < data1.Length; i++)
                    {
                        Console.WriteLine($"data[{i}]memory address= 0x{(long)(ptr + i):X}");
                        //ptr+i指標會自動判斷i的資料型態並轉呈byte
                    }
                }
                Console.WriteLine("=================");
                fixed (int* ptr = data1)//指標
                {
                    int cols = data2.GetLength(1);//用getlength(1)可以知道一列幾人
                    for (int i = 0; i < data2.GetLength(0); i++)//getlength(0)第一維度(看上下)
                    {
                        for (int j = 0; j < data2.GetLength(1); j++)//用getlength(1)第二維度(看左右)
                        {
                            int*address=ptr+(i*cols+j);//i*cols前面滿列的有幾個，j看自己本身列的前面有幾個。
                            Console.WriteLine($"data[{i},{j}]memory address= 0x{(long)(address):X}");
                        }
                    }
                }
            }
        }
    }
}

```

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308768300070604810/image.png?ex=673f24f6&is=673dd376&hm=38bf86e57d19cb8ef829fc7c005f831dd2358e364e0772a0d59bd591cae8c517&=)

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308768134232145960/image.png?ex=673f24ce&is=673dd34e&hm=a72bb44700186310a549d0417e4b056e6247438baaffb487c9005877ba2187bc&=)



- <style type="text/css"></style>
  
  | [0,0] | [0,1] | [0,2] | [0,3] | [0,4] |
  | ----- | ----- | ----- | ----- | ----- |
  | [1,0] | [1,1] | [1,2] | [1,3] | [1,4] |
  
  上方二維陣列為[2][5]的大小

### 。直為行(欄)、橫為列

#### <mark>陣列表示法</mark>​

- **以列為主**的表示方法 (Row Major)​
  
  - 一列一列來依序儲存，例如C/C++、Java、PASCAL語言的陣列存放方式。​
  - 由[0,0]~[0,4]先放入後再由[1,0]~[1,4]依序放入

- **以欄(行)為主**的表示方法 (Column Major)​
  
  - 一行一行來依序儲存，例如Fortran語言的陣列存放方式。
  
  - 由[0,0]、[1,0]、[0,1]、[1,1].....依序放入

#### 一維陣列的表示法

##### <mark>。前面站多少人，每個人多胖</mark>

<style type="text/css"></style>

|      | 表示陣列大小            | 尋找位置              |
|:----:|:-----------------:|:-----------------:|
| 一維陣列 | A[n]              | A[i]              |
| 二維陣列 | A[m][n]           | A[i][j]           |
| 三維陣列 | A[L][m][n]        | A[i][j][k]        |
| 四維陣列 | A[S1][S2][S3][S4] | A[i1][i2][i3][i4] |

<style type="text/css"></style>

A[i]的位置計算公式為：

A的起始位址+A[i]的前面之人數*元素所需的儲存空間的z位元組(byte)

=a+i*z

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308781704835629157/image.png?ex=673f3172&is=673ddff2&hm=9d8c4ab95079e704a64a5cb3ec086ec5f377d82682fb8e6f1624973308b07b76&=)

=========================================================

###### 一維陣列的表示法​

**<mark>例題：</mark>**

。【例1】設陣列A是一個大小為10的一維陣列，且陣列A在記憶體之起始位置為1000，且每個元素都需要2個位元組的儲存空間。則 A[7]的記憶體位置為何？​



------------------------------------------------------------------------------------------------------------------------

解答：

Loc(A[7]) = A的起始位址 + A[7]相對於陣列起始位置之位移​  
= 1000 + 7* 2​  
= 1014。 ​

===================================================================

。【例2】設d[100] 為一個實數陣列，每一個元素佔4個位元組。若d[10]的位址為2000，則d[88]的位址為何？



-----------------------------------------------------------------------------------

解答：

Loc(d[88]) = d[10]的位址 + d[88]相對於d[10]之位移​  
= 2000 + (88-10)**4​  
= 2312。

=======================================================================

##### 一維陣列的註標表示法

A[f:t] = {A[f] ，A[f-1] ，... ， A[0] ，A[1] ， ... ，A[t] } 。

舉例：

A[10]，轉成一維陣列註標表示是A[0:9]

舉例

A[-3:7] =>共有11數在-3~7之間

================================================================

- 【例3】設A[-15:25]在記憶體的起始位置為123，且每一元素佔4個位元組，則A[3]的位址為何？ ​



-------------------------------------------------------------------------------------------------------------------

解答：

A[-15:25]=轉成一般=>A[41]

Loc(A[3]) =123+ (2-(-15)+1*4)

=195

====================================================================

#### <mark> 。二維陣列表示法</mark>

##### 。 <u><mark>以列為主(Row Major) ​</mark></u>

- 假設：

- 二維陣列B在記憶體的起始位置為α 。​

- 陣列之個別元素所需的記憶體空間大小為z 。​

- 陣列元素B[i][j]的記憶體位址為Loc(B[i][j]) 。

則

- LocRM(B[i][j]) = B的起始位址 + B[i][j]相對於陣列起始位置之位移​  
  = α + (i*n + j)*z 。​

--------------------------------------------------------------------------------------

<style type="text/css"></style>

|     | 0   | 1   | 2   | 3           | 4   |
| ---:| --- | --- | --- | ----------- | --- |
| 0   |     |     |     |             |     |
| 1   |     |     |     | /////////// |     |
| 2   |     |     |     |             |     |



B[3][5]上方的陣列大小

尋找B[1][3]位置

=>初始位置

=>1個滿列所以為5

=>自己本身列之前面有多少人? 3人

=>還有資料型態的byte要記得乘上去

所以LocalB[1][3]=1000+(1*5+3)*4



### 。 <u><mark>列為主(Row Major) ​</mark></u>

公式：α + (i*n + j)*z 。

a =>初始位址

i =>前面有幾列

n =>每列有多少人

j =>本身該列之前面有多少人

z =>資料型態byte，ex:int 為4byte

====================================================

#### 。<mark>行為主(Column Major)的表示法</mark>

<style type="text/css"></style>

|     | 0   | 1   | 2   | 3          | 4   |
| ---:| --- | --- | --- | ---------- | --- |
| 0   |     |     |     |            |     |
| 1   |     |     |     | ////////// |     |
| 2   |     |     |     |            |     |

B[3][5]上方的陣列大小

尋找B[1][3]位置

放入順序會依序由[0,0]、[1,0]、[2.0]、[0,1]、[1,1]、[2,1].....放入

公式：**B[i][j]**

LocB[1][3] = a+(j*m+i)*z

=>B[1][3]=1000+(3*3+1)*4

a =>初始位址

j =>前面有幾行

m =>每行有多少人

i =>本身該行之前面有多少人

z =>資料型態byte，ex :int 為4byte



==============================================================

【例1】已知A[1][2]之記憶體位置為22，且**A[2][4]和A[4][2]** 之記憶體位置分別為30和40，則A[5][5]之位置為何？



-------------------------------------------------------------------------------------------------------------------

。假設以列為主=>A<u>[2]</u>[4]會先進去則A[4][2]會大於A[2][4]

第二列先進去，再第四列

所以30小於40 符合

--------------------

。假設以行為主=>A[4]**<u>[2]</u>** 先進去則A[2][4]後進去，但A[4][2]大於A[2][4]不合理，不可能依序放入後前者大於後者。

===================================================================

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308805091679010847/image.png?ex=673f473a&is=673df5ba&hm=f56a669bc94f9f1fddcee3c11f6eb954cba8b6226b71e3f4331d6dc11d40fccf&=)

22+(1*n+2)*z=30

(1*n)=>為22之後到下一列的原本位置之前+2

22+(3*n)*z=40

解聯立：

nz+2z=8

3nz=18

nz=6

z=1

n=6

  

==================================================================

因為A[2][4]的記憶體位置30小於A[4][2] 的記憶體位置40，可見該陣列是採「以列為主」排列。因此：

LocRM(A[2][4]) = A[1][2]的位址 + A[2][4]相對於A[1][2]之位移​

= 22 + ((2-1)* n + (4-2)) * z​

= 22 + (n + 2)* z = 30。​

所以，nz + 2z = 8 …………(1) ​

​

LocRM(A[4][2]) = A[1][2]的位址 + A[4][2]相對於A[1][2]之位移​

= 22 + ((4-1) *n + (2-2)) *z​

= 22 + (3n + 0) *z = 40。​

​

所以，3nz = 18 ，nz = 6 …………(2) ，將(2)代入(1)得到​

6 + 2z = 8，z = 1，代入(2) 得到 n = 6 ，因此 ​

​

LocRM(A[5][5]) = A[1][2]的位址 + A[5][5]相對於A[1][2]之位移​  
= 22 + ((5-1) *n + (5-2))  z​  
= 22 + (4 * 6 + 3)*1 ​  
= 49。​

-=====================================================



三維陣列表示法：

int cubic[3][2][3]

列為主=>由左至右看

行為主=>由右至左看



=>列為主

尋找[1][1][2]

 ================================================================

![](https://cdn.discordapp.com/attachments/1303971581025980426/1308813115915374724/image.png?ex=673f4eb3&is=673dfd33&hm=d3f327f4b041f8b6812f9bc1f4d56c6a0a9828aa682bc26faf05a43169284ad1&=)



列=>由左至右 =>依序往右下乘

行=>由右至左 =>依序往左下乘

上排：尋找位址

下排：陣列大小



















value time referce time int屬於哪種?
物件層級、class層級、屬性，變數，int a 哪個層級

pravite 、public ...變數的存取

**遞迴特性：**

。反覆執行的遞迴過程

。跳出執行過程的出口

。直接遞迴：直接自己呼叫自己

。間接遞迴：本身 -呼叫-> B -呼叫-> C -> 本身 ，造成記憶體負擔增加，較依次佔一次記憶體空間。

遞迴：用硬體資源去化簡軟體複雜。

陣列走訪搭配結構：
